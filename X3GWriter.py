# Copyright (c) 2017 Ghostkeeper
# Cura is released under the terms of the AGPLv3 or higher.

import io
import subprocess
import os
import tempfile

from cura.Settings.ExtruderManager import ExtruderManager
from UM.Mesh.MeshWriter import MeshWriter
from UM.Logger import Logger
from UM.Application import Application
from UM.Settings.SettingDefinition import SettingDefinition, DefinitionPropertyType
import UM.Platform

class X3GWriter(MeshWriter):
    def __init__(self):
        super().__init__()
        self._gcode = None
        # Add properties needed for x3g printers
        SettingDefinition.addSupportedProperty("steps_per_mm", DefinitionPropertyType.Any, default = 0, read_only = False)
        SettingDefinition.addSupportedProperty("endstop_is_max", DefinitionPropertyType.Any, default = 0, read_only = False)
        SettingDefinition.addSupportedProperty("steps_per_revolution", DefinitionPropertyType.Any, default = 0, read_only = False)

    ##  Build a GPX configuration file containing printer definitions.
    #
    def build_config(self):
        output_config=[] # config, one string per line

        # pull params
        steps_per_mm_x = Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_width", "steps_per_mm")
        steps_per_mm_y = Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_depth", "steps_per_mm")
        steps_per_mm_z = Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_height", "steps_per_mm")
        machine_max_feedrate_x = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_feedrate_x", "value"))*60
        machine_max_feedrate_y = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_feedrate_y", "value"))*60
        machine_max_feedrate_z = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_feedrate_z", "value"))*60
        machine_max_feedrate_e = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_feedrate_e", "value"))*60
        machine_max_acceleration_x = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_acceleration_x", "value"))
        machine_max_acceleration_y = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_acceleration_y", "value"))
        machine_max_acceleration_z = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_acceleration_z", "value"))
        machine_max_acceleration_e = float(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_max_acceleration_e", "value"))
        machine_heated_bed = int(Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_heated_bed", "value") == True)

        machine_endstop_x = Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_width", "endstop_is_max")
        machine_endstop_y = Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_depth", "endstop_is_max")
        machine_endstop_z = Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_height", "endstop_is_max")

        extruders = ExtruderManager.getInstance().getExtruderStacks()

        if len(extruders) > 2:
            Logger.log("e", "X3G based printer has %s extruders, can only have one or two!", len(extruders))

        # Info on where this came from
        output_config.append("# GPX config generated by X3GWriter")
        output_config.append("# Printer name: ") #FIXME
        # write out reasonable defaults
        output_config.append("[printer]")
        output_config.append("gcode_flavor=makerbot")
        output_config.append("build_progress=1") # generate build progress % in output x3g
        output_config.append("ditto_printing=0") # disable ditto printing in firmware
        output_config.append("nominal_filament_diameter=1.75") #FIXME
        output_config.append("jkn_k=0.0085") #FIXME
        output_config.append("jkn_k2=0.0090") #FIXME
        output_config.append("extruder_count={}".format(len(extruders)))

        # Skip [right] and [left] since defaults are OK (don't want to override gcode)

        output_config.append("[x]") # X params
        output_config.append("max_feedrate={}".format(machine_max_feedrate_x))
        output_config.append("max_acceleration={}".format(machine_max_acceleration_x))
        output_config.append("max_speed_change={}".format(machine_max_acceleration_x**0.5))
        output_config.append("home_feedrate={}".format(2500)) #FIXME
        output_config.append("steps_per_mm={}".format(steps_per_mm_x)) # steps per mm
        output_config.append("endstop={}".format(machine_endstop_x))

        output_config.append("[y]") # Y params
        output_config.append("max_feedrate={}".format(machine_max_feedrate_y))
        output_config.append("max_acceleration={}".format(machine_max_acceleration_y))
        output_config.append("max_speed_change={}".format(machine_max_acceleration_y**0.5))
        output_config.append("home_feedrate={}".format(2500)) #FIXME
        output_config.append("steps_per_mm={}".format(steps_per_mm_y)) # steps per mm
        output_config.append("endstop={}".format(machine_endstop_y))

        output_config.append("[z]") # Z params
        output_config.append("max_feedrate={}".format(machine_max_feedrate_z))
        output_config.append("max_acceleration={}".format(machine_max_acceleration_z))
        output_config.append("max_speed_change={}".format(machine_max_acceleration_z**0.5))
        output_config.append("home_feedrate={}".format(2500)) #FIXME
        output_config.append("steps_per_mm={}".format(steps_per_mm_z)) # steps per mm
        output_config.append("endstop={}".format(machine_endstop_z))

        for e in extruders:
            if e.getProperty("extruder_nr", "value") == 0:
                extruder_val = "[a]"
            elif e.getProperty("extruder_nr", "value") == 1:
                extruder_val = "[b]"
            else:
                Logger.log("e", "X3G based printer extruder %s has bad index!", e.getProperty("extruder_nr", "value"))

            extr_steps_per_mm = e.getProperty("extruder_nr", "steps_per_mm")
            extr_steps_per_rev = e.getProperty("extruder_nr", "steps_per_revolution")

            output_config.append(extruder_val) # Extruder param name
            output_config.append("max_feedrate={}".format(machine_max_feedrate_e))
            output_config.append("max_acceleration={}".format(machine_max_acceleration_e))
            output_config.append("max_speed_change={}".format(machine_max_acceleration_e**0.5))
            output_config.append("steps_per_mm={}".format(extr_steps_per_mm)) # steps per mm
            output_config.append("motor_steps={}".format(extr_steps_per_rev))
            output_config.append("has_heated_build_platform={}".format(machine_heated_bed))

        tmp_file_fd, tmp_file_path = tempfile.mkstemp(prefix = "gpxconfig", suffix=".ini", text = True)
        tmp_file = os.fdopen(tmp_file_fd, "w")
        tmp_file.write("\n".join(output_config))
        tmp_file.close()
        return tmp_file_path


    ##  Write the X3G data to a stream.
    #
    #   \param stream The stream to write X3G data to.
    #   \param nodes A sequence of nodes to write to the stream.
    #   \param mode The output mode to use. This is ignored, since it has no
    #   meaning.
    def write(self, stream, nodes, mode = MeshWriter.OutputMode.TextMode):

        machine_extruder_count = Application.getInstance().getGlobalContainerStack().getBottom().getProperty("machine_extruder_count", "value")
        Logger.log("d", "machine_extruder_count: %s", machine_extruder_count)

        cfg_file = self.build_config()

        #Get the g-code.
        scene = Application.getInstance().getController().getScene()
        gcode_list = getattr(scene, "gcode_list")
        if not gcode_list:
            return False

        #Find an unused file name to temporarily write the g-code to.
        file_name = stream.name
        if not file_name: #Not a file stream.
            Logger.log("e", "X3G writer can only write to local files.")
            return False
        file_directory = os.path.dirname(os.path.realpath(file_name)) #Save the tempfile next to the real output file.
        i = 0
        temp_file = os.path.join(file_directory, "output" + str(i) + ".gcode")
        while os.path.isfile(temp_file):
            i += 1
            temp_file = os.path.join(file_directory, "output" + str(i) + ".gcode")

        #Write the g-code to the temporary file.
        try:
            with open(temp_file, "w", -1, "utf-8") as f:
                for gcode in gcode_list:
                    f.write(gcode)
        except:
            Logger.log("e", "Error writing temporary g-code file %s", temp_file)
            _removeTemporary(temp_file)
            return False

        #Call the converter application to convert it to X3G.
        Logger.log("d", "App path: %s", os.getcwd())
        Logger.log("d", "File name: %s", file_name)
        binary_path = os.path.dirname(os.path.realpath(__file__))
        binary_filename = os.path.join(binary_path, "gpx")
        if UM.Platform.Platform.isWindows():
            binary_filename += ".exe"
        if UM.Platform.Platform.isOSX(): #For the cross-platform release, we need to disambiguate between MacOS and Linux.
            if os.path.isfile(binary_filename + "_macos"): #Still fall back to the default name if the MacOS-specific file doesn't exist.
                binary_filename += "_macos"

        command = [binary_filename, "-p", "-c", cfg_file, temp_file, file_name]
        safes = [os.path.expandvars(p) for p in command]
        Logger.log("d", "Command: %s", str(command))
        stream.close() #Close the file so that the binary can write to it.
        try:
            process = subprocess.Popen(safes)
            process.wait()
            output = process.communicate(b"y")
            Logger.log("d", str(output))
        except Exception as e:
            Logger.log("e", "System call to X3G converter application failed: %s", str(e))
            _removeTemporary(temp_file)
            return False

        _removeTemporary(temp_file)
        _removeTemporary(cfg_file)
        return True

##  Removes the temporary g-code file that is an intermediary result.
#
#   This should be called at the end of the write, also if the write failed.
#   \param temp_file The URI of the temporary file.
def _removeTemporary(temp_file):
    try:
        os.remove(temp_file)
    except:
        Logger.log("w", "Couldn't remove temporary file %s", temp_file)
